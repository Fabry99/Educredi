import {
  dataTables_default
} from "./chunk-5WTSSG5T.js";
import {
  require_jquery
} from "./chunk-OGVVV2AK.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/datatables.net-colreorder/js/dataTables.colReorder.mjs
var import_jquery = __toESM(require_jquery(), 1);
var $ = import_jquery.default;
function arrayMove(arr, from, count, to) {
  var movers = arr.splice(from, count);
  movers.unshift(0);
  movers.unshift(to < from ? to : to - count + 1);
  arr.splice.apply(arr, movers);
}
function finalise(dt) {
  dt.rows().invalidate("data");
  dt.column(0).visible(dt.column(0).visible());
  dt.columns.adjust();
  var order = dt.colReorder.order();
  dt.trigger("columns-reordered", [
    {
      order,
      mapping: invertKeyValues(order)
    }
  ]);
}
function getOrder(dt) {
  return dt.settings()[0].aoColumns.map(function(col) {
    return col._crOriginalIdx;
  });
}
function headerUpdate(structure, map, from, to) {
  var done = [];
  for (var i = 0; i < structure.length; i++) {
    var headerRow = structure[i];
    arrayMove(headerRow, from[0], from.length, to);
    for (var j = 0; j < headerRow.length; j++) {
      var cell = headerRow[j].cell;
      if (done.includes(cell)) {
        continue;
      }
      var indexes = cell.getAttribute("data-dt-column").split(",");
      var mapped = indexes.map(function(idx) {
        return map[idx];
      }).join(",");
      cell.setAttribute("data-dt-column", mapped);
      done.push(cell);
    }
  }
}
function init(api) {
  api.columns().iterator("column", function(s, idx) {
    var columns = s.aoColumns;
    if (columns[idx]._crOriginalIdx === void 0) {
      columns[idx]._crOriginalIdx = idx;
    }
  });
}
function invertKeyValues(arr) {
  var result = [];
  for (var i = 0; i < arr.length; i++) {
    result[arr[i]] = i;
  }
  return result;
}
function move(dt, from, to) {
  var i, j;
  var settings = dt.settings()[0];
  var columns = settings.aoColumns;
  var newOrder = columns.map(function(col, idx) {
    return idx;
  });
  if (from.includes(to)) {
    return;
  }
  arrayMove(newOrder, from[0], from.length, to);
  var reverseIndexes = invertKeyValues(newOrder);
  arrayMove(columns, from[0], from.length, to);
  for (i = 0; i < settings.aoData.length; i++) {
    var data = settings.aoData[i];
    if (!data) {
      continue;
    }
    var cells = data.anCells;
    if (!cells) {
      continue;
    }
    arrayMove(cells, from[0], from.length, to);
    for (j = 0; j < cells.length; j++) {
      if (data.nTr && cells[j] && columns[j].bVisible) {
        data.nTr.appendChild(cells[j]);
      }
      if (cells[j] && cells[j]._DT_CellIndex) {
        cells[j]._DT_CellIndex.column = j;
      }
    }
  }
  for (i = 0; i < columns.length; i++) {
    var column = columns[i];
    for (j = 0; j < column.aDataSort.length; j++) {
      column.aDataSort[j] = reverseIndexes[column.aDataSort[j]];
    }
    column.idx = reverseIndexes[column.idx];
    if (column.bVisible) {
      settings.colgroup.append(column.colEl);
    }
  }
  headerUpdate(settings.aoHeader, reverseIndexes, from, to);
  headerUpdate(settings.aoFooter, reverseIndexes, from, to);
  arrayMove(settings.aoPreSearchCols, from[0], from.length, to);
  orderingIndexes(reverseIndexes, settings.aaSorting);
  if (Array.isArray(settings.aaSortingFixed)) {
    orderingIndexes(reverseIndexes, settings.aaSortingFixed);
  } else if (settings.aaSortingFixed.pre) {
    orderingIndexes(reverseIndexes, settings.aaSortingFixed.pre);
  } else if (settings.aaSortingFixed.post) {
    orderingIndexes(reverseIndexes, settings.aaSortingFixed.pre);
  }
  settings.aLastSort.forEach(function(el) {
    el.src = reverseIndexes[el.src];
  });
  dt.trigger("column-reorder", [
    dt.settings()[0],
    {
      from,
      to,
      mapping: reverseIndexes
    }
  ]);
}
function orderingIndexes(map, order) {
  if (!order) {
    return;
  }
  for (var i = 0; i < order.length; i++) {
    var el = order[i];
    if (typeof el === "number") {
      order[i] = map[el];
    } else if ($.isPlainObject(el) && el.idx !== void 0) {
      el.idx = map[el.idx];
    } else if (Array.isArray(el) && typeof el[0] === "number") {
      el[0] = map[el[0]];
    }
  }
}
function setOrder(dt, order, original) {
  var changed = false;
  var i;
  if (order.length !== dt.columns().count()) {
    dt.error("ColReorder - column count mismatch");
    return;
  }
  if (original) {
    order = transpose(dt, order, "toCurrent");
  }
  var setOrder2 = invertKeyValues(order);
  for (i = 0; i < setOrder2.length; i++) {
    var currentIndex = setOrder2.indexOf(i);
    if (i !== currentIndex) {
      arrayMove(setOrder2, currentIndex, 1, i);
      move(dt, [currentIndex], i);
      changed = true;
    }
  }
  if (changed) {
    finalise(dt);
  }
}
function structureFill(structure) {
  var filledIn = [];
  for (var row = 0; row < structure.length; row++) {
    filledIn.push([]);
    for (var col = 0; col < structure[row].length; col++) {
      var cell = structure[row][col];
      if (cell) {
        for (var rowInner = 0; rowInner < cell.rowspan; rowInner++) {
          if (!filledIn[row + rowInner]) {
            filledIn[row + rowInner] = [];
          }
          for (var colInner = 0; colInner < cell.colspan; colInner++) {
            filledIn[row + rowInner][col + colInner] = cell.cell;
          }
        }
      }
    }
  }
  return filledIn;
}
function transpose(dt, idx, dir) {
  var order = dt.colReorder.order();
  var columns = dt.settings()[0].aoColumns;
  if (dir === "toCurrent" || dir === "fromOriginal") {
    return !Array.isArray(idx) ? order.indexOf(idx) : idx.map(function(index) {
      return order.indexOf(index);
    });
  }
  return !Array.isArray(idx) ? columns[idx]._crOriginalIdx : idx.map(function(index) {
    return columns[index]._crOriginalIdx;
  });
}
function validateMove(table, from, to) {
  var columns = table.columns().count();
  if (from[0] < to && to < from[from.length]) {
    return false;
  }
  if (from[0] < 0 && from[from.length - 1] > columns) {
    return false;
  }
  if (to < 0 && to > columns) {
    return false;
  }
  if (from.includes(to)) {
    return true;
  }
  if (!validateStructureMove(table.table().header.structure(), from, to)) {
    return false;
  }
  if (!validateStructureMove(table.table().footer.structure(), from, to)) {
    return false;
  }
  return true;
}
function validateStructureMove(structure, from, to) {
  var header = structureFill(structure);
  var i;
  for (i = 0; i < header.length; i++) {
    arrayMove(header[i], from[0], from.length, to);
  }
  for (i = 0; i < header.length; i++) {
    var seen = [];
    for (var j = 0; j < header[i].length; j++) {
      var cell = header[i][j];
      if (!seen.includes(cell)) {
        seen.push(cell);
      } else if (seen[seen.length - 1] !== cell) {
        return false;
      }
    }
  }
  return true;
}
var ColReorder = (
  /** @class */
  function() {
    function ColReorder2(dt, opts) {
      this.dom = {
        drag: null
      };
      this.c = {
        columns: null,
        enable: null,
        order: null
      };
      this.s = {
        dropZones: [],
        mouse: {
          absLeft: -1,
          offset: {
            x: -1,
            y: -1
          },
          start: {
            x: -1,
            y: -1
          },
          target: null,
          targets: []
        },
        scrollInterval: null
      };
      var that = this;
      var ctx = dt.settings()[0];
      if (ctx._colReorder) {
        return;
      }
      dt.settings()[0]._colReorder = this;
      this.dt = dt;
      $.extend(this.c, ColReorder2.defaults, opts);
      init(dt);
      dt.on("stateSaveParams", function(e, s, d) {
        d.colReorder = getOrder(dt);
      });
      dt.on("destroy", function() {
        dt.off(".colReorder");
        dt.colReorder.reset();
      });
      var loaded = dt.state.loaded();
      var order = this.c.order;
      if (loaded && loaded.colReorder) {
        order = loaded.colReorder;
      }
      if (order) {
        dt.ready(function() {
          setOrder(dt, order, true);
        });
      }
      dt.table().header.structure().forEach(function(row) {
        for (var i = 0; i < row.length; i++) {
          if (row[i] && row[i].cell) {
            that._addListener(row[i].cell);
          }
        }
      });
    }
    ColReorder2.prototype.disable = function() {
      this.c.enable = false;
      return this;
    };
    ColReorder2.prototype.enable = function(flag) {
      if (flag === void 0) {
        flag = true;
      }
      if (flag === false) {
        return this.disable();
      }
      this.c.enable = true;
      return this;
    };
    ColReorder2.prototype._addListener = function(el) {
      var that = this;
      $(el).on("selectstart.colReorder", function() {
        return false;
      }).on("mousedown.colReorder touchstart.colReorder", function(e) {
        if (e.type === "mousedown" && e.which !== 1) {
          return;
        }
        if (!that.c.enable) {
          return;
        }
        that._mouseDown(e, this);
      });
    };
    ColReorder2.prototype._createDragNode = function() {
      var origCell = this.s.mouse.target;
      var origTr = origCell.parent();
      var origThead = origTr.parent();
      var origTable = origThead.parent();
      var cloneCell = origCell.clone();
      this.dom.drag = $(origTable[0].cloneNode(false)).addClass("dtcr-cloned").append(
        $(origThead[0].cloneNode(false)).append($(origTr[0].cloneNode(false)).append(cloneCell[0]))
        // Not sure why  it doesn't want to append a jQuery node
      ).css({
        position: "absolute",
        top: 0,
        left: 0,
        width: $(origCell).outerWidth(),
        height: $(origCell).outerHeight()
      }).appendTo("body");
    };
    ColReorder2.prototype._cursorPosition = function(e, prop) {
      return e.type.indexOf("touch") !== -1 ? e.originalEvent.touches[0][prop] : e[prop];
    };
    ColReorder2.prototype._mouseDown = function(e, cell) {
      var _this = this;
      var target = $(e.target).closest("th, td");
      var offset = target.offset();
      var moveableColumns = this.dt.columns(this.c.columns).indexes().toArray();
      var moveColumnIndexes = $(cell).attr("data-dt-column").split(",").map(function(val) {
        return parseInt(val, 10);
      });
      for (var j = 0; j < moveColumnIndexes.length; j++) {
        if (!moveableColumns.includes(moveColumnIndexes[j])) {
          return false;
        }
      }
      this.s.mouse.start.x = this._cursorPosition(e, "pageX");
      this.s.mouse.start.y = this._cursorPosition(e, "pageY");
      this.s.mouse.offset.x = this._cursorPosition(e, "pageX") - offset.left;
      this.s.mouse.offset.y = this._cursorPosition(e, "pageY") - offset.top;
      this.s.mouse.target = target;
      this.s.mouse.targets = moveColumnIndexes;
      for (var i = 0; i < moveColumnIndexes.length; i++) {
        var cells = this.dt.cells(null, moveColumnIndexes[i], { page: "current" }).nodes().to$();
        var klass = "dtcr-moving";
        if (i === 0) {
          klass += " dtcr-moving-first";
        }
        if (i === moveColumnIndexes.length - 1) {
          klass += " dtcr-moving-last";
        }
        cells.addClass(klass);
      }
      this._regions(moveColumnIndexes);
      this._scrollRegions();
      $(document).on("mousemove.colReorder touchmove.colReorder", function(e2) {
        _this._mouseMove(e2);
      }).on("mouseup.colReorder touchend.colReorder", function(e2) {
        _this._mouseUp(e2);
      });
    };
    ColReorder2.prototype._mouseMove = function(e) {
      if (this.dom.drag === null) {
        if (Math.pow(Math.pow(this._cursorPosition(e, "pageX") - this.s.mouse.start.x, 2) + Math.pow(this._cursorPosition(e, "pageY") - this.s.mouse.start.y, 2), 0.5) < 5) {
          return;
        }
        $(document.body).addClass("dtcr-dragging");
        this._createDragNode();
      }
      this.dom.drag.css({
        left: this._cursorPosition(e, "pageX") - this.s.mouse.offset.x,
        top: this._cursorPosition(e, "pageY") - this.s.mouse.offset.y
      });
      var tableOffset = $(this.dt.table().node()).offset().left;
      var cursorMouseLeft = this._cursorPosition(e, "pageX") - tableOffset;
      var dropZone = this.s.dropZones.find(function(zone) {
        if (zone.left <= cursorMouseLeft && cursorMouseLeft <= zone.left + zone.width) {
          return true;
        }
        return false;
      });
      this.s.mouse.absLeft = this._cursorPosition(e, "pageX");
      if (!dropZone) {
        return;
      }
      if (!dropZone.self) {
        this._move(dropZone, cursorMouseLeft);
      }
    };
    ColReorder2.prototype._mouseUp = function(e) {
      $(document).off(".colReorder");
      $(document.body).removeClass("dtcr-dragging");
      if (this.dom.drag) {
        this.dom.drag.remove();
        this.dom.drag = null;
      }
      if (this.s.scrollInterval) {
        clearInterval(this.s.scrollInterval);
      }
      this.dt.cells(".dtcr-moving").nodes().to$().removeClass("dtcr-moving dtcr-moving-first dtcr-moving-last");
    };
    ColReorder2.prototype._move = function(dropZone, cursorMouseLeft) {
      var that = this;
      this.dt.colReorder.move(this.s.mouse.targets, dropZone.colIdx);
      this.s.mouse.targets = $(this.s.mouse.target).attr("data-dt-column").split(",").map(function(val) {
        return parseInt(val, 10);
      });
      this._regions(this.s.mouse.targets);
      var visibleTargets = this.s.mouse.targets.filter(function(val) {
        return that.dt.column(val).visible();
      });
      var dz = this.s.dropZones.find(function(zone) {
        return zone.colIdx === visibleTargets[0];
      });
      var dzIdx = this.s.dropZones.indexOf(dz);
      if (dz.left > cursorMouseLeft) {
        var previousDiff = dz.left - cursorMouseLeft;
        var previousDz = this.s.dropZones[dzIdx - 1];
        dz.left -= previousDiff;
        dz.width += previousDiff;
        if (previousDz) {
          previousDz.width -= previousDiff;
        }
      }
      dz = this.s.dropZones.find(function(zone) {
        return zone.colIdx === visibleTargets[visibleTargets.length - 1];
      });
      if (dz.left + dz.width < cursorMouseLeft) {
        var nextDiff = cursorMouseLeft - (dz.left + dz.width);
        var nextDz = this.s.dropZones[dzIdx + 1];
        dz.width += nextDiff;
        if (nextDz) {
          nextDz.left += nextDiff;
          nextDz.width -= nextDiff;
        }
      }
    };
    ColReorder2.prototype._regions = function(moveColumns) {
      var that = this;
      var dropZones = [];
      var totalWidth = 0;
      var negativeCorrect = 0;
      var allowedColumns = this.dt.columns(this.c.columns).indexes().toArray();
      var widths = this.dt.columns().widths();
      this.dt.columns().every(function(colIdx, tabIdx, i) {
        if (!this.visible()) {
          return;
        }
        var columnWidth = widths[colIdx];
        if (!allowedColumns.includes(colIdx)) {
          totalWidth += columnWidth;
          return;
        }
        var valid = validateMove(that.dt, moveColumns, colIdx);
        if (valid) {
          dropZones.push({
            colIdx,
            left: totalWidth - negativeCorrect,
            self: moveColumns[0] <= colIdx && colIdx <= moveColumns[moveColumns.length - 1],
            width: columnWidth + negativeCorrect
          });
        } else if (colIdx < moveColumns[0]) {
          if (dropZones.length) {
            dropZones[dropZones.length - 1].width += columnWidth;
          }
        } else if (colIdx > moveColumns[moveColumns.length - 1]) {
          negativeCorrect += columnWidth;
        }
        totalWidth += columnWidth;
      });
      this.s.dropZones = dropZones;
    };
    ColReorder2.prototype._isScrolling = function() {
      return this.dt.table().body().parentNode !== this.dt.table().header().parentNode;
    };
    ColReorder2.prototype._scrollRegions = function() {
      if (!this._isScrolling()) {
        return;
      }
      var that = this;
      var tableLeft = $(this.dt.table().container()).position().left;
      var tableWidth = $(this.dt.table().container()).outerWidth();
      var mouseBuffer = 75;
      var scrollContainer = this.dt.table().body().parentElement.parentElement;
      this.s.scrollInterval = setInterval(function() {
        var mouseLeft = that.s.mouse.absLeft;
        if (mouseLeft < tableLeft + mouseBuffer && scrollContainer.scrollLeft) {
          scrollContainer.scrollLeft -= 5;
        } else if (mouseLeft > tableLeft + tableWidth - mouseBuffer && scrollContainer.scrollLeft < scrollContainer.scrollWidth) {
          scrollContainer.scrollLeft += 5;
        }
      }, 25);
    };
    ColReorder2.defaults = {
      columns: "",
      enable: true,
      order: null
    };
    ColReorder2.version = "2.0.4";
    return ColReorder2;
  }()
);
dataTables_default.Api.register("colReorder.enable()", function(flag) {
  return this.iterator("table", function(ctx) {
    if (ctx._colReorder) {
      ctx._colReorder.enable(flag);
    }
  });
});
dataTables_default.Api.register("colReorder.disable()", function() {
  return this.iterator("table", function(ctx) {
    if (ctx._colReorder) {
      ctx._colReorder.disable();
    }
  });
});
dataTables_default.Api.register("colReorder.move()", function(from, to) {
  init(this);
  if (!Array.isArray(from)) {
    from = [from];
  }
  if (!validateMove(this, from, to)) {
    this.error("ColReorder - invalid move");
    return this;
  }
  return this.tables().every(function() {
    move(this, from, to);
    finalise(this);
  });
});
dataTables_default.Api.register("colReorder.order()", function(set, original) {
  init(this);
  if (!set) {
    return this.context.length ? getOrder(this) : null;
  }
  return this.tables().every(function() {
    setOrder(this, set, original);
  });
});
dataTables_default.Api.register("colReorder.reset()", function() {
  init(this);
  return this.tables().every(function() {
    var order = this.columns().every(function(i) {
      return i;
    }).flatten().toArray();
    setOrder(this, order, true);
  });
});
dataTables_default.Api.register("colReorder.transpose()", function(idx, dir) {
  init(this);
  if (!dir) {
    dir = "toCurrent";
  }
  return transpose(this, idx, dir);
});
dataTables_default.ColReorder = ColReorder;
$(document).on("stateLoadInit.dt", function(e, settings, state) {
  if (e.namespace !== "dt") {
    return;
  }
  var dt = new dataTables_default.Api(settings);
  if (state.colReorder) {
    if (dt.ready()) {
      setOrder(dt, state.colReorder, true);
    } else {
      orderingIndexes(state.colReorder, state.order);
      if (state.columns) {
        for (var i = 0; i < state.columns.length; i++) {
          state.columns[i]._cr_sort = state.colReorder[i];
        }
        state.columns.sort(function(a, b) {
          return a._cr_sort - b._cr_sort;
        });
      }
    }
  }
});
$(document).on("preInit.dt", function(e, settings) {
  if (e.namespace !== "dt") {
    return;
  }
  var init2 = settings.oInit.colReorder;
  var defaults = dataTables_default.defaults.colReorder;
  if (init2 || defaults) {
    var opts = $.extend({}, defaults, init2);
    if (init2 !== false) {
      var dt = new dataTables_default.Api(settings);
      new ColReorder(dt, opts);
    }
  }
});
var dataTables_colReorder_default = dataTables_default;
export {
  dataTables_colReorder_default as default
};
/*! Bundled license information:

datatables.net-colreorder/js/dataTables.colReorder.mjs:
  (*! ColReorder 2.0.4
   * © SpryMedia Ltd - datatables.net/license
   *)
*/
//# sourceMappingURL=datatables__net-colreorder.js.map
